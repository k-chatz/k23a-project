<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>K23a Project: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">K23a Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">K23a Project Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a></p><h1 align="center">ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ ΓΙΑ ΠΛΗΡΟΦΟΡΙΑΚΑ ΣΥΣΤΗΜΑΤΑ</h1>
<p><br  />
</p>
<p align="center"></p>
<p><br  />
 <b>Entity resolution</b> <br  />
 </p>
<p><br  />
</p>
<p align="center"></p>
<p><br  />
 <a href="https://k23a-prj-auth.herokuapp.com" target="_blank"><b>Documentation</b></a> <br  />
 </p>
<p><br  />
</p>
<p align="center"></p>
<p><br  />
</p>
<p><a href="https://discord.gg/nSGmntAX"><img src="https://img.shields.io/discord/765286458243153950?color=7389d8&amp;label=Discord&amp;logo=Discord&amp;logoColor=fff" alt="Discord" class="inline"/>  </a> <br  />
</p>
<p><br  />
</p>
<hr  />
<p> <br  />
</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Εθνικό και Καποδιστριακό Πανεπιστήμιο Αθηνών</h1>
<h3><a class="anchor" id="autotoc_md9"></a>
Τμήμα Πληροφορικής και Τηλεπικοινωνιών</h3>
<h3><a class="anchor" id="autotoc_md10"></a>
Κ23Α - ΑΝΑΠΤΥΞΗ ΛΟΓΙΣΜΙΚΟΥ ΓΙΑ ΠΛΗΡΟΦΟΡΙΑΚΑ ΣΥΣΤΗΜΑΤΑ</h3>
<h3><a class="anchor" id="autotoc_md11"></a>
&lt;strong&gt;Project - Entity resolution&lt;/strong&gt;</h3>
<p><b>Μέλη</b>: <br  />
</p><ul>
<li>Θεόδωρος Χατζηιωαννίδης - 1115201600197 <br  />
</li>
<li>Βασίλειος Πουλόπουλος - 1115201600141 <br  />
</li>
<li>Κωνσταντίνος Χατζόπουλος - 1115201300202 <br  />
</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
Περιεχόμενα</h2>
<ol type="1">
<li><a href="#procedure">Διαδικαστικά</a></li>
<li><a href="#intro">Εισαγωγή</a></li>
<li><a href="#hash_table">Hash table</a></li>
<li><a href="#list">Generic List</a></li>
<li><a href="#json_parser">JSON Parser</a></li>
<li><a href="#spec_to_specs">Spec to specs</a></li>
<li><a href="#urand">Unique rand</a></li>
<li><a href="#machine_learning">Μηχανική Μάθηση</a></li>
<li><a href="#parallel">Παραλληλοποίηση</a></li>
<li><a href="#unit_tests">Unit tests</a></li>
<li><a href="#documentation">Documentation</a> <a class="anchor" id="procedure"></a> <br  />
 </li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
Διαδικαστικά</h2>
<h3><a class="anchor" id="autotoc_md14"></a>
Κλήση Προγραμμάτων</h3>
<p>Για να εκτελεστούν τα πρόγραμμα από τερματικό τρέχουμε το script 'build_and_run.sh'. <br  />
</p>
<p>Τα ορίσματα που δέχεται το εκτελέσιμο για το training είναι τα εξής: <br  />
</p>
<ul>
<li>-dir { dataset X path } <br  />
</li>
<li>-csv { dataset W path } <br  />
</li>
<li>-sw { stopwords file path } <br  />
</li>
<li>-m { tfidf | bow } <br  />
</li>
<li>-ex {resources path } <br  />
</li>
</ul>
<p>Τα ορίσματα που δέχεται το εκτελέσιμο για το predicting είναι τα εξής: <br  />
</p><ul>
<li>-dir {user dataset X path} <br  />
</li>
<li>-csv {user dataset W path} <br  />
</li>
<li>-vocabulary {vocabulary path} <br  />
</li>
<li>-model {model path} <br  />
</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
Ενδεικτική εκτέλεση προγράμματος Training</h3>
<p>&gt;./project -dir Datasets/camera_specs/2013_camera_specs \ &gt;-csv Datasets/sigmod_large_labelled_dataset.csv \ &gt;-ex resources \ &gt;-m tfidf \ &gt;-sw resources/unwanted-words.txt</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Ενδεικτική εκτέλεση προγράμματος Predicting</h3>
<blockquote class="doxtable">
<p>./user -dir Datasets/camera_specs/2013_camera_specs \ -csv resources/datasets/user_dataset.csv \ -vocabulary resources/vocabulary.csv \ -model resources/models/best_model.csv</p>
<p></p>
</blockquote>
<p>### Έξοδος προγράμματος Training <br  />
</p>
<p><b>predictions</b> και <b>f1 score</b> για το validation set <br  />
</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Έξοδος προγράμματος Testing</h3>
<p><b>predicitons</b> για το dataset που δίνει ο χρήστης. <br  />
</p>
<p><b>Σημείωση</b>: Για να περάσουμε το model και το vocabulary από το ένα πρόγραμμα στο άλλο, τα γράψαμε σε αρχεία. <br  />
</p>
<p><a class="anchor" id="intro"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md18"></a>
Εισαγωγή</h2>
<p>Στόχος της άσκησης είναι να δημιουργήσουμε κλίκες γράφων από αγγελίες με τα ίδια προϊόντα σε διάφορα sites.</p>
<p>Αφού δημιουργηθούν οι κλίκες, δημιουργούνται και οι αρνητικές συσχετίσεις μεταξύ των κλικών (κάθε κλίκα αναγνωρίζει ποιες κλίκες είναι διαφορετικές από αυτή).</p>
<p>Στη συνέχεια δημιουργούνται όλα τα ζευγάρια από <b>similar</b> και <b>different</b> αγγελίες μέσω των κλικών και χρησιμοποιούνται ως δεδομένα για να εκπαιδευτεί ένα μοντέλο το οποίο θα μαντεύει αν τα ζευγάρια που δέχεται είναι similar ή different.</p>
<p>Η διαδικασία προετοιμασίας της εκπαίδευσης, καθώς και του testing, παραλληλοποιείται μέσω ενός <b>job scheduler</b>.</p>
<p>Για την ολοκλήρωση του project χρειάστηκε να υλοποιήσουμε τα παρακάτω <b>modules</b>: <br  />
</p>
<ul>
<li><b>hash table</b></li>
<li><b>dictionary</b></li>
<li><b>hash set</b></li>
<li><b>queue</b></li>
<li><b>spec to specs</b></li>
<li><b>generic list</b> <br  />
</li>
<li><b>job scheduler</b></li>
<li><b>json parser</b> <br  />
</li>
<li><b>tokenizer</b><ul>
<li><b>unique rand</b></li>
<li><b>machine learning</b></li>
<li><b>logistic regration</b></li>
<li><b>custom semaphore</b></li>
</ul>
</li>
</ul>
<p>Επιπλέον, για τον έλεγχο ορθότητας του κώδικα, χρησιμοποιήσαμε τη βιβλιοθήκη <b>acutest.h</b> όπου δέχεται μια λίστα από κατάλληλες συναρτήσεις (<b>tests</b>) που γράψαμε. <br  />
 <a class="anchor" id="hash_table"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md19"></a>
Hash table</h2>
<p><img src="https://raw.githubusercontent.com/vasilisp100/k23a-project/master/resources/hash.png?token=AOECAYY7EWIICN4TZXIPN7TAC3IQ4" alt="hash table" class="inline"/> <br  />
</p>
<p><em>Αναπαράσταση της δομής του hash table:</em> <br  />
 </p><div class="fragment"><div class="line"><span class="keyword">typedef</span>  <span class="keyword">struct </span><a class="code" href="structhtab__s.html">htab_s</a> {  </div>
<div class="line">    ht_hash_func <a class="code" href="structhtab__s.html#a19a6f98d448a6e3bc6140e9eda393a48">h</a>;  </div>
<div class="line">    ht_cmp_func <a class="code" href="structhtab__s.html#a86ac020f20ab1efa23711fec3ef2f7cf">cmp</a>; </div>
<div class="line">    ht_key_cpy_func <a class="code" href="structhtab__s.html#a810080f8b4c5355fb15ba5cc4fb17364">keycpy</a>; </div>
<div class="line">    <span class="keywordtype">size_t</span> <a class="code" href="structhtab__s.html#a34ed69269093a550b7eb86c5774aa402">key_sz</a>; </div>
<div class="line">    <span class="keywordtype">size_t</span> <a class="code" href="structhtab__s.html#a8c2ab395e0c6aaf721a63c49a5352ece">val_sz</a>; </div>
<div class="line">    ulong <a class="code" href="structhtab__s.html#a472e4249f98200a928ed1c406e4aad27">buf_cap</a>;  </div>
<div class="line">    ulong <a class="code" href="structhtab__s.html#a8365c1eca17c6a80214a3a3e17b0e9ef">buf_load</a>; </div>
<div class="line">    <span class="keywordtype">char</span> <a class="code" href="structhtab__s.html#a2d102a84e231caee47b0f507fef98cfa">buf</a>[]; </div>
<div class="line">} <a class="code" href="group__htab.html#gac0cb518811d32006d78e617452a0a602">htab_t</a>; </div>
<div class="ttc" id="agroup__htab_html_gac0cb518811d32006d78e617452a0a602"><div class="ttname"><a href="group__htab.html#gac0cb518811d32006d78e617452a0a602">htab_t</a></div><div class="ttdeci">struct htab_s htab_t</div><div class="ttdoc">hashtable ADT with open addressing and random probing</div></div>
<div class="ttc" id="astructhtab__s_html"><div class="ttname"><a href="structhtab__s.html">htab_s</a></div><div class="ttdoc">hashtable ADT with open addressing and random probing</div><div class="ttdef"><b>Definition:</b> hash.h:63</div></div>
<div class="ttc" id="astructhtab__s_html_a19a6f98d448a6e3bc6140e9eda393a48"><div class="ttname"><a href="structhtab__s.html#a19a6f98d448a6e3bc6140e9eda393a48">htab_s::h</a></div><div class="ttdeci">ht_hash_func h</div><div class="ttdoc">hash function used to hash the keys</div><div class="ttdef"><b>Definition:</b> hash.h:65</div></div>
<div class="ttc" id="astructhtab__s_html_a2d102a84e231caee47b0f507fef98cfa"><div class="ttname"><a href="structhtab__s.html#a2d102a84e231caee47b0f507fef98cfa">htab_s::buf</a></div><div class="ttdeci">char buf[]</div><div class="ttdoc">the buffer where the entries are stored</div><div class="ttdef"><b>Definition:</b> hash.h:80</div></div>
<div class="ttc" id="astructhtab__s_html_a34ed69269093a550b7eb86c5774aa402"><div class="ttname"><a href="structhtab__s.html#a34ed69269093a550b7eb86c5774aa402">htab_s::key_sz</a></div><div class="ttdeci">size_t key_sz</div><div class="ttdoc">size of key in the hashtable</div><div class="ttdef"><b>Definition:</b> hash.h:72</div></div>
<div class="ttc" id="astructhtab__s_html_a472e4249f98200a928ed1c406e4aad27"><div class="ttname"><a href="structhtab__s.html#a472e4249f98200a928ed1c406e4aad27">htab_s::buf_cap</a></div><div class="ttdeci">ulong buf_cap</div><div class="ttdoc">capacity of buf</div><div class="ttdef"><b>Definition:</b> hash.h:76</div></div>
<div class="ttc" id="astructhtab__s_html_a810080f8b4c5355fb15ba5cc4fb17364"><div class="ttname"><a href="structhtab__s.html#a810080f8b4c5355fb15ba5cc4fb17364">htab_s::keycpy</a></div><div class="ttdeci">ht_key_cpy_func keycpy</div><div class="ttdoc">copying function that copies a key to the hashtable (default: memcpy)</div><div class="ttdef"><b>Definition:</b> hash.h:70</div></div>
<div class="ttc" id="astructhtab__s_html_a8365c1eca17c6a80214a3a3e17b0e9ef"><div class="ttname"><a href="structhtab__s.html#a8365c1eca17c6a80214a3a3e17b0e9ef">htab_s::buf_load</a></div><div class="ttdeci">ulong buf_load</div><div class="ttdoc">occupied entries of buf</div><div class="ttdef"><b>Definition:</b> hash.h:78</div></div>
<div class="ttc" id="astructhtab__s_html_a86ac020f20ab1efa23711fec3ef2f7cf"><div class="ttname"><a href="structhtab__s.html#a86ac020f20ab1efa23711fec3ef2f7cf">htab_s::cmp</a></div><div class="ttdeci">ht_cmp_func cmp</div><div class="ttdoc">comparison function to compare 2 keys (default: memcmp)</div><div class="ttdef"><b>Definition:</b> hash.h:67</div></div>
<div class="ttc" id="astructhtab__s_html_a8c2ab395e0c6aaf721a63c49a5352ece"><div class="ttname"><a href="structhtab__s.html#a8c2ab395e0c6aaf721a63c49a5352ece">htab_s::val_sz</a></div><div class="ttdeci">size_t val_sz</div><div class="ttdoc">size of val in the hashtable</div><div class="ttdef"><b>Definition:</b> hash.h:74</div></div>
</div><!-- fragment --><p> Για την υλοποίηση του hash table, χρησιμοποιήσαμε generic <b>open addressing hash table</b> με <a href="http://luc.devroye.org/1997notes/topic13/">random probing</a>. <br  />
 Πιο συγκεκριμένα, δεσμεύουμε ένα κομμάτι μνήμης το οποίο χωρίζεται σε μικροτέρα ίσα μέρη στα οποία αποθηκεύονται οι πληροφορίες του κάθε <b>spec</b>. <br  />
</p>
<p>Αφού χρησιμοποιούμε random probing το κάθε spec ανάλογα με το key του, αν δε χωράει στην πρώτη θέση που θα υπολογιστεί μέσω του hash function, θα ψάξει κάποια "τυχαία" θέση για να αποθηκευθεί. Το seed της random συνάρτησης είναι σταθερό, οπότε πάντα μπορούμε να υπολογίσουμε σε ποιο σημείο της μνήμης βρίσκονται τα εκάστοτε δεδομένα. <br  />
</p>
<p>Αν η μνήμη που έχουμε δεσμεύσει αρχίσει να γεμίζει θα κάνουμε <b>Rehashing</b>. Όταν θέλουμε να εισάγουμε νέα δεδομένα αλλά η πληρότητα του είναι <b>70%</b>, δεσμεύουμε τη διπλάσια μνήμη από πριν, ξαναμοιράζουμε τα δεδομένα στην καινούργια, μεγαλύτερη μνήμη και εισάγουμε τα νέα δεδομένα. <br  />
</p>
<p><a class="anchor" id="list"></a> <br  />
</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Generic List</h2>
<p>Χρησιμοποιήσαμε μία <b>generic list</b> όπου δηλώνεται με τη χρήση του παρακάτω macro:</p>
<p><em>Αναπαράσταση της δομής του κόμβου:</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define  LISTOF(TYPE)   \</span></div>
<div class="line"><span class="preprocessor">    struct {            \</span></div>
<div class="line"><span class="preprocessor">    void *next;         \</span></div>
<div class="line"><span class="preprocessor">    TYPE data;          \</span></div>
<div class="line"><span class="preprocessor">}</span></div>
</div><!-- fragment --><p>Η λίστα αποτελείται από απλούς κόμβους δεδομένων <code>TYPE data;</code> οι οποίοι περιέχουν τα ίδια τα δεδομένα καθώς και έναν δείκτη στον επόμενο κόμβο. Είναι στην ουσία ένας <b>wrapper</b> ο οποίος επικαλύπτει τα δεδομένα, προσθέτοντάς τους έναν δείκτη <code>void *next;</code> για τα επόμενα δεδομένα.</p>
<p>Λόγω της σειράς που ορίζεται το πεδίο του επόμενου κόμβου (<code>void *next;</code>) στον wrapper, είναι εύκολο να αποκτηθεί πρόσβαση στον επόμενο κόμβο με τη χρήση του παρακάτω macro: </p><div class="fragment"><div class="line"><span class="preprocessor">#define  NEXT(x) (*((void **)x))</span></div>
</div><!-- fragment --><p> όπου επιστρέφει έναν δείκτη στον επόμενο κόμβο πιο άμεσα.</p>
<p><a class="anchor" id="json_parser"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md21"></a>
JSON Parser</h2>
<p>O json parser ακολουθεί τη γραμματική του <a href="https://www.json.org/">json.org</a> .</p>
<p>Πιο συγκεκριμένα, κάθε οντότητα του json περιγράφεται από την παρακάτω δομή:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__json__parser.html#gac75c61993722a9b8aaa44704072ec06c">json_type</a> type;</div>
<div class="line">    <span class="keywordtype">char</span> data[];</div>
<div class="line">} <a class="code" href="structJSON__ENTITY.html">JSON_ENTITY</a>;</div>
<div class="ttc" id="agroup__json__parser_html_gac75c61993722a9b8aaa44704072ec06c"><div class="ttname"><a href="group__json__parser.html#gac75c61993722a9b8aaa44704072ec06c">json_type</a></div><div class="ttdeci">json_type</div><div class="ttdoc">The possible types of a json value.</div><div class="ttdef"><b>Definition:</b> json_parser.h:47</div></div>
<div class="ttc" id="astructJSON__ENTITY_html"><div class="ttname"><a href="structJSON__ENTITY.html">JSON_ENTITY</a></div><div class="ttdoc">The representation used for json values.</div><div class="ttdef"><b>Definition:</b> json_parser.h:68</div></div>
</div><!-- fragment --><p> όπου το <b>data[]</b> περιέχει την ίδια την οντότητα, ενώ το <b>type</b>, περιγράφει τον τύπο της οντότητας, και μπορεί να λάβει οποιαδήποτε από τις τιμές του παρακάτω <b>enum</b>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    <a class="code" href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca9dc70cc7977798040165b727be04e79b">JSON_OBJ</a>,</div>
<div class="line">    <a class="code" href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca97462341a4eba4320d62d49597eabb6a">JSON_ARRAY</a>,</div>
<div class="line">    <a class="code" href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca19402a672c69b64246e4e290926a9a43">JSON_NUM</a>,</div>
<div class="line">    <a class="code" href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06cafc3a60886010e5b0f57d7aa30d0277b0">JSON_BOOL</a>,</div>
<div class="line">    <a class="code" href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca02bfd03b07e5b9ecd6ee0d257dc37daf">JSON_STRING</a>,</div>
<div class="line">    <a class="code" href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca03ddcc4e2eef955020a01e10c11bfe48">JSON_NULL</a></div>
<div class="line">} <a class="code" href="group__json__parser.html#gac75c61993722a9b8aaa44704072ec06c">json_type</a>;</div>
<div class="ttc" id="agroup__json__parser_html_ggac75c61993722a9b8aaa44704072ec06ca02bfd03b07e5b9ecd6ee0d257dc37daf"><div class="ttname"><a href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca02bfd03b07e5b9ecd6ee0d257dc37daf">JSON_STRING</a></div><div class="ttdeci">@ JSON_STRING</div><div class="ttdef"><b>Definition:</b> json_parser.h:57</div></div>
<div class="ttc" id="agroup__json__parser_html_ggac75c61993722a9b8aaa44704072ec06ca03ddcc4e2eef955020a01e10c11bfe48"><div class="ttname"><a href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca03ddcc4e2eef955020a01e10c11bfe48">JSON_NULL</a></div><div class="ttdeci">@ JSON_NULL</div><div class="ttdef"><b>Definition:</b> json_parser.h:59</div></div>
<div class="ttc" id="agroup__json__parser_html_ggac75c61993722a9b8aaa44704072ec06ca19402a672c69b64246e4e290926a9a43"><div class="ttname"><a href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca19402a672c69b64246e4e290926a9a43">JSON_NUM</a></div><div class="ttdeci">@ JSON_NUM</div><div class="ttdef"><b>Definition:</b> json_parser.h:53</div></div>
<div class="ttc" id="agroup__json__parser_html_ggac75c61993722a9b8aaa44704072ec06ca97462341a4eba4320d62d49597eabb6a"><div class="ttname"><a href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca97462341a4eba4320d62d49597eabb6a">JSON_ARRAY</a></div><div class="ttdeci">@ JSON_ARRAY</div><div class="ttdef"><b>Definition:</b> json_parser.h:51</div></div>
<div class="ttc" id="agroup__json__parser_html_ggac75c61993722a9b8aaa44704072ec06ca9dc70cc7977798040165b727be04e79b"><div class="ttname"><a href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06ca9dc70cc7977798040165b727be04e79b">JSON_OBJ</a></div><div class="ttdeci">@ JSON_OBJ</div><div class="ttdef"><b>Definition:</b> json_parser.h:49</div></div>
<div class="ttc" id="agroup__json__parser_html_ggac75c61993722a9b8aaa44704072ec06cafc3a60886010e5b0f57d7aa30d0277b0"><div class="ttname"><a href="group__json__parser.html#ggac75c61993722a9b8aaa44704072ec06cafc3a60886010e5b0f57d7aa30d0277b0">JSON_BOOL</a></div><div class="ttdeci">@ JSON_BOOL</div><div class="ttdef"><b>Definition:</b> json_parser.h:55</div></div>
</div><!-- fragment --><p><a class="anchor" id="spec_to_specs"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md22"></a>
Spec to specs</h2>
<p>Ο τρόπος με τον οποίο συνδέουμε τα στοιχεία των κλικών μεταξύ τους, είναι μέσω μίας δενδρικής αναπαράστασης. Το πρώτο spec που θα μπει στην κλίκα είναι ο πατέρας, ενώ τα υπόλοιπα είναι τα παιδιά του. Αν δύο κλίκες γίνουν <b>merge</b>, τότε ο πατέρας της δεύτερης κλίκας αποθηκεύεται στον παππού της πρώτης. Με αυτό τον τρόπο κρατάμε το δένδρο σε χαμηλά επίπεδα. <br  />
</p>
<p>To <b>spec to specs</b> είναι η δομή που χρησιμοποιούμε για το ζητούμενο της άσκησης. Στην ουσία είναι ένα hash table, στο οποίο το κάθε στοιχείο που αποθηκεύεται είναι της μορφής: <br  />
 </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structSpecEntry__s.html">SpecEntry_s</a> {  </div>
<div class="line">      <span class="keywordtype">char</span> *<a class="code" href="structSpecEntry__s.html#a38d7e29e2a029fa13700dcd2597853f7">id</a>;   </div>
<div class="line">      <span class="keywordtype">char</span> *<a class="code" href="structSpecEntry__s.html#ace7105861cfe9a90fc7b78d24cc7101a">parent</a>;</div>
<div class="line">      StrList *<a class="code" href="structSpecEntry__s.html#aa475be2eddf3f4b407c98addb65a8f74">similar</a>, *similar_tail, *different, *different_tail;   </div>
<div class="line">      ulong <a class="code" href="structSpecEntry__s.html#a65d95811b88f1bfa7154d9b6535b53bf">similar_len</a>, different_len;  </div>
<div class="line">      <span class="keywordtype">bool</span> printed;  </div>
<div class="line">}; </div>
<div class="ttc" id="astructSpecEntry__s_html"><div class="ttname"><a href="structSpecEntry__s.html">SpecEntry_s</a></div><div class="ttdoc">STS hashtable entry.</div><div class="ttdef"><b>Definition:</b> spec_to_specs.h:49</div></div>
<div class="ttc" id="astructSpecEntry__s_html_a38d7e29e2a029fa13700dcd2597853f7"><div class="ttname"><a href="structSpecEntry__s.html#a38d7e29e2a029fa13700dcd2597853f7">SpecEntry_s::id</a></div><div class="ttdeci">char * id</div><div class="ttdoc">spec id</div><div class="ttdef"><b>Definition:</b> spec_to_specs.h:51</div></div>
<div class="ttc" id="astructSpecEntry__s_html_a65d95811b88f1bfa7154d9b6535b53bf"><div class="ttname"><a href="structSpecEntry__s.html#a65d95811b88f1bfa7154d9b6535b53bf">SpecEntry_s::similar_len</a></div><div class="ttdeci">ulong similar_len</div><div class="ttdoc">Length of similar.</div><div class="ttdef"><b>Definition:</b> spec_to_specs.h:60</div></div>
<div class="ttc" id="astructSpecEntry__s_html_aa475be2eddf3f4b407c98addb65a8f74"><div class="ttname"><a href="structSpecEntry__s.html#aa475be2eddf3f4b407c98addb65a8f74">SpecEntry_s::similar</a></div><div class="ttdeci">StrList * similar</div><div class="ttdoc">Contents of the set if this node is the representative of the set, this is the list of the elements; ...</div><div class="ttdef"><b>Definition:</b> spec_to_specs.h:58</div></div>
<div class="ttc" id="astructSpecEntry__s_html_ace7105861cfe9a90fc7b78d24cc7101a"><div class="ttname"><a href="structSpecEntry__s.html#ace7105861cfe9a90fc7b78d24cc7101a">SpecEntry_s::parent</a></div><div class="ttdeci">char * parent</div><div class="ttdoc">Set of similar specs.</div><div class="ttdef"><b>Definition:</b> spec_to_specs.h:53</div></div>
</div><!-- fragment --><p> Ο <b>parent</b> είναι ο πατέρας του spec (αν δεν είναι σε κλίκα τότε έχει για πατέρα τον εαυτό του). Η <b>similar</b> είναι μία λίστα στην οποία, αν το spec είναι parent κάποιας κλίκας αποθηκεύονται τα ids όλης της κλίκας, σε αντίθετη περίπτωση της ανατίθεται η τιμή NULL, ενώ το <b>similar_tail</b> είναι δείκτης στο τελευταίο στοιχείο της similar. Το similar_len είναι το μέγεθος της similar. <br  />
</p>
<p>Για τον υπολογισμό των διαφορετικών κλικών (<b>different</b>) βάλαμε άλλη μία λίστα στην οποία βρίσκονται οι root κάθε κλίκας που είναι διαφορετική. Αν για παράδειγμα είχαμε τη συσχέτιση "Α, Β, 0", ο root του Α θα συμπεριλάμβανε το root του Β στην different λίστα του, όπως και ο root του Β θα συμπεριλάμβανε το root του Α στη δική του different λίστα.</p>
<p><em>Αναπαράσταση εισαγωγής κλίκας:</em> <img src="https://raw.githubusercontent.com/vasilisp100/k23a-project/master/resources/cliques.gif?token=AOECAY7ODGOEUUQACONOD3LAC3IOG" alt="cliques" class="inline"/></p>
<p><a class="anchor" id="urand"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md23"></a>
Unique rand</h2>
<p>Για την επιλογή τυχαίων και ταυτόχρονα μοναδικών ακέραιων τιμών στα σύνολα (<b>train</b>, <b>test</b>, <b>validation</b>) υπήρξε η ανάγκη να υλοποιηθεί ένα module (<code>urand</code>) που θα μας επιστρέφει τυχαίες τιμές καλώντας τη <code>ur_get</code> εξασφαλίζοντας έτσι, ότι τις ίδιες αυτές τιμές που πήραμε δε θα τις ξαναπάρουμε σε μεταγενέστερη κλήση της συνάρτησης.</p>
<p><em>Αναπαράσταση της δομής <a class="el" href="structunique__rand.html">unique_rand</a>:</em> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structunique__rand.html">unique_rand</a> {  </div>
<div class="line">    <span class="keywordtype">int</span> min;  </div>
<div class="line">    <span class="keywordtype">int</span> max;  </div>
<div class="line">    <span class="keywordtype">int</span> *values;  </div>
<div class="line">    <span class="keywordtype">int</span> length;  </div>
<div class="line">};</div>
<div class="ttc" id="astructunique__rand_html"><div class="ttname"><a href="structunique__rand.html">unique_rand</a></div><div class="ttdef"><b>Definition:</b> unique_rand.c:8</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Δημιουργία</h3>
<p>Κατά τη δημιουργία αυτού του module καλώντας τη συνάρτηση <code>ur_create</code>, είναι απαραίτητο να δοθεί σε αυτήν μια ελάχιστη (min) και μια μέγιστη (max) τιμή ώστε να καθοριστεί το εύρος των τυχαίων τιμών που θα επιστρέφει η <code>ur_get</code>. Επομένως, με το εύρος τιμών γίνεται υπολογισμός του πλήθους αυτών, δεσμεύεται δυναμικά ένας πίνακας ακέραιων μεγέθους <code>max - min + 1</code> και αμέσως μετά αρχικοποιείται με τιμές που ξεκινούν από <code>min</code>.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Λειτουργικότητα</h3>
<p>Αφού έχει δημιουργηθεί με επιτυχία το <code>URand *ur</code> αντικείμενο τότε κάθε φορά που καλείται η <code>ur_get</code> επιλέγεται τυχαία μια θέση από τον πίνακα <code>values</code> για να επιστραφεί το περιεχόμενό της στον χρήστη, η θέση αυτή γίνεται <b>swap</b> με την αντίστοιχη θέση που δείχνει εκείνη τη στιγμή η τιμή <code>ur-&gt;length</code> δηλαδή προς το τέλος. Αυτό έχει ως αποτέλεσμα, οι τιμές εκείνες που έχει πάρει ο χρήστης να μετακινούνται προς το τέλος του πίνακα <code>values</code> καθώς μειώνεται η μεταβλητή <code>ur-&gt;length</code>.</p>
<p><a class="anchor" id="machine_learning"></a> </p>
<h2><a class="anchor" id="autotoc_md26"></a>
Μηχανική Μάθηση</h2>
<p>Αρχικά έπρεπε να δημιουργηθεί το <b>vocabulary</b> σύμφωνα με το οποίο θα φτιάχνονταν τα διανύσματα για να γίνει το <b>training</b> και το <b>testing</b>. Έτσι δημιουργήσαμε το vocabulary με όλες τις διαφορετικές λέξεις των JSON αρχείων.</p>
<p>Για να μειωθούν οι διαστάσεις δε συμπεριλάβαμε <b>stopwords</b>, <b>punctuations</b> και <b>αριθμούς</b>, όπως και κάποιες λέξεις που θεωρούμε πως δε φέρουν χρήσιμη πληροφορία αφού υπάρχουν σε σχεδόν όλα τα αρχεία (πχ το "mm"). Στη συνέχεια αν ο χρήστης έχει δώσει την επιλογή <b>tfidf</b>, αφαιρούμε από το vocabulary τις λέξεις με μεγάλο <b>idf</b>. Για να γίνει η διαδικασία επιλογής λέξεων δοκιμάσαμε τις παρακάτω μεθόδους:</p><ul>
<li>Η πρώτη μέθοδος ήταν να χρησιμοποιήσουμε συναρτήσεις όπως η <b>strtok</b> και <b>strcat</b>.</li>
<li>H δεύτερη ήταν να τροποποιήσουμε τον <b>tokenizer</b> που έχουμε υλοποιήσει για τον <b>json parser</b> και να υλοποιήσουμε τη συνάρτηση <b>tokenizer_nlp_sw()</b> που αναλαμβάνει να επιστρέψει μόνο τις λέξεις που πληρούν τα κριτήριά αγνοώντας τις υπόλοιπες.</li>
</ul>
<p>Παρατηρήσαμε πως η δεύτερη μέθοδος ήταν πιο γρήγορη οπότε και την προτιμήσαμε για το τελικό μας πρόγραμμα. Παρ' όλα αυτά υπάρχουν και οι δύο υλοποιήσεις καθώς και τα test τους στο repository.</p>
<p>Στη συνέχεια φτιάξαμε το <b>διάνυσμα</b> (bow ή tfidf ανάλογα με την προτίμηση του χρήστη) για το κάθε JSON και τα αποθηκεύσαμε σε ένα hash table για να τα έχουμε έτοιμα όταν τα χρειαστούμε.</p>
<p>Για να δημιουργηθεί το <b>dataset</b> για το <b>train</b>, <b>test</b> και <b>validation</b> ακολουθήθηκε η εξής διαδικασία:</p>
<p>Αρχικά, δημιουργήθηκαν όλα τα similar και different ζευγάρια μέσω των κλικών. Αυτό ήταν το συνολικό dataset. Στη συνέχεια κρατήσαμε τυχαία το <b>50% των similar</b> και το <b>50% των different</b> και τα ενώσαμε σε ένα πίνακα. Αυτός ο πίνακας αποτελεί το train set. Κάναμε την ίδια διαδικασία με <b>25% για το test set</b> και τα υπόλοιπα <b>25% για το validation set</b>. Έτσι, είχαμε τα τρία sets που χρειαζόμασταν.</p>
<p>****Για να δημιουργήσουμε το διάνυσμα κάθε ζευγαριού, χρησιμοποιούμε την απόλυτη διαφορά των διανυσμάτων json1-json2.*</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Εκπαίδευση μοντέλου</h3>
<p>Για την εκπαίδευση υλοποιήσαμε <b>mini batch gradient decent</b>. Σε κάθε <b>epoch</b> αρχικά γίνεται training για το training set και στη συνέχεια γίνεται predict για το test set ώστε να υπολογίζουμε το μέσο**loss** σε κάθε <b>epoch</b>, με το σκεπτικό αν παρατηρήσουμε συνεχή αύξηση του μέσου loss για 5 συνεχόμενα epochs, να κρατήσουμε το μοντέλο που είχε υπολογιστεί πριν 5 epochs και να σταματήσουμε τη διαδικασία του <b>training</b>. Παρατηρήσαμε όμως πως μέχρι τα 2000 <b>epochs</b> που το τεστάραμε ακόμα δεν έγινε break.</p>
<p>Στο τέλος του training κάνουμε <b>predict</b> για το validation set, τυπώνουμε τα predictions (με κόκκινο χρώμα τα λανθασμένα και με πράσινο τα σωστά) και στη συνέχεια υπολογίζουμε το <b>F1 score</b></p>
<h3><a class="anchor" id="autotoc_md28"></a>
Εξαγωγή μοντέλου και λεξιλογίου σε αρχεία</h3>
<p>Έχει υλοποιηθεί και δεύτερη main (<b>user.c</b>) η οποία κάνει μόνο <b>predict</b> ότι δώσει ο χρήστης σαν είσοδο. Χρησιμοποιώντας το <b>vocabulary</b> και το <b>model</b> που έχουν γίνει export από την πρώτη main. Για το λόγο αυτό το vocabulary και το τελικό model γίνονται export σε αρχεία ώστε να δοθούν ως είσοδο σε αυτήν.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Επαναληπτική εκμάθηση</h3>
<p>Η διαδικασία που ακολουθούσαμε ήταν να χρησιμοποιήσουμε όλο το dataset (<b>train + test + val sets</b>) για αρχικό training set. Για threshold είχαμε αρχικά <b>0.0</b> ωστε να προστεθούν στο dataset μόνο όσα ζευγάρια γίνονταν predict me <b>0</b> ή <b>1</b> και σε κάθε επανάληψη το threshold αυξανόταν κατά <b>0.01</b>. Για όλα τα υπόλοιπα πιθανά ζευγάρια (δηλαδή όλα τα ζευγάρια απο specs για τα οποία δεν ξέρουμε τη σχέση τους, κάναμε <b>predict</b>. Αν το μοντέλο μας ήταν αρκετά "σίγουρο", δηλαδή αν ίσχυε η συνθήκη "``
if (p(x,b) &lt; threshold) or (p(x,b) &gt; 1 - threshold)``", προσθέταμε όλες τις συσχετίσεις που προέκυπταν από αυτό το prediction στο <b>training set</b> ώστε στην επόμενη επανάληψη να ληφθούν και αυτά στο train. Συνεχίζαμε τη διαδικασία για όσο το <b>threshold</b> ήταν &lt; <b>0,5</b>.</p>
<p>Για να ξέρουμε ποια ζευγάρια βρίσκονται στο <b>training set</b> χρησιμοποιοαμε ένα hash table του οποίου τα κλειδιά είναι τα ονόματα των ζευγαριών του <b>training set</b> άλλα και τα αντίστροφά τους, δηλαδή αν το ζευγάρι <b>Α,Β</b> μπει στο training set, στο hash table μπαίνει και το Α,Β και το Β,Α ώστε να μην μπει και με τους δύο τρόπους το ίδιο ζευγάρι.</p>
<p>Παρατηρήσαμε πως από την πρώτη επανάληψη της επαναληπτικής μάθησης, επειδή ο αριθμός των ζευγαριών που προστίθενται στο <b>training set</b> ήταν πολύ μεγάλος ο χώρος της μνήμης γέμιζε με αποτέλεσμα να τερματίζει το πρόγραμμα. Για αυτό το λόγο, δοκιμάσαμε να γράφουμε σε αρχείο το <b>training set</b> ώστε να μη γεμίζει η μνήμη. Παρόλα αυτά και πάλι γέμιζε η μνήμη λόγω του hash table.</p>
<p>Για αυτό το λόγο ακολουθήσαμε δύο προσεγγίσεις ώστε να μην μπαίνουν τόσα πολλά ζευγάρια στο dataset. Αρχικά σταματήσαμε να δεχόμαστε τα ζευγάρια των οποίων έστω το ένα από τα 2 specs ήταν σε κλίκα. Με αυτό τον τρόπο ουσιαστικά οι ήδη υπάρχουσες κλίκες δε μεγάλωναν, αλλά φτιάχνονταν καινούργιες. Επίσης, βάλαμε ανώτατο όριο, να δέχεται μέχρι <b>500.000</b> καινούργια ζευγάρια.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Γενικές παρατηρήσεις για την επαναληπτική μάθηση</h3>
<p>Μέσω της διαγραφής των λέξεων με μεγάλο <b>idf</b> κρατήσαμε τις καλύτερες <b>911</b> και όχι <b>1000</b> γιατί το αμέσως μεγαλύτερο idf κρατάει άλλες <b>161</b> λέξεις που σημαίνει πως ξεπερνάμε τις <b>1000</b>.</p>
<p>Παρατηρήσαμε ότι για <b>2000 epochs</b>, <b>0,0001 learning rate</b> και <b>batch size 2000</b> παίρνουμε αρκετά καλό <b>f1 score</b> της τάξης του <b>0,93</b> από την πρώτη φορά που γίνεται train (πριν τη διαδικασία της επαναληπτικής μάθησης).</p>
<p>Επίσης, την πρώτη φορά που γίνεται <b>train</b> το μοντέλο, πριν την επαναληπτική μάθηση, κάθε epoch ολοκληρώνεται σε περίπου <b>0,4</b> δευτερόλεπτα. Στην επαναληπτική μάθηση, όσο μεγαλώνει το dataset, κάθε epoch γίνεται και πιο αργό, αφού πρέπει να γίνουν train περισσότερα ζευγάρια.</p>
<p><a class="anchor" id="parallel"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md31"></a>
Παραλληλοποίηση</h2>
<p>Για τη γρηγορότερη εκπαίδευση του μοντέλου υλοποιήθηκε ένας <b>Job Scheduler</b> που αναλαμβάνει να δημιουργήσει νέα νήματα (<b>workers</b>). Κάθε worker τρέχει πολλαπλά Jobs σειριακά τα οποία εξάγονται από μια κοινόχρηστη ουρά το ένα μετά το άλλο προσθέτοντας έτσι παραλληλία. </p>
<h3><a class="anchor" id="autotoc_md32"></a>
Βασικές δομές</h3>
<p><em>Αναπαράσταση της δομής job:</em> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structjob.html">job</a> {</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> job_id;  </div>
<div class="line">    <span class="keywordtype">void</span> *(*start_routine)(<span class="keywordtype">void</span> *);</div>
<div class="line">    <span class="keywordtype">int</span> args_count;  </div>
<div class="line">    <a class="code" href="structargument.html">Argument</a> *args;  </div>
<div class="line">    <span class="keywordtype">void</span> *return_val;  </div>
<div class="line">    <span class="keywordtype">bool</span> complete;  </div>
<div class="line">    <span class="comment">/* sync */</span>  </div>
<div class="line">    sem_t sem_complete;  </div>
<div class="line">};</div>
<div class="ttc" id="astructargument_html"><div class="ttname"><a href="structargument.html">argument</a></div><div class="ttdef"><b>Definition:</b> job_scheduler.c:33</div></div>
<div class="ttc" id="astructjob_html"><div class="ttname"><a href="structjob.html">job</a></div><div class="ttdef"><b>Definition:</b> job_scheduler.c:38</div></div>
</div><!-- fragment --><p> Κάθε νέο <b>job</b> που δημιουργείται μέσω της συνάρτησής <b>js_create_job()</b> έχει τα παρακάτω χαρακτηριστικά:</p><ul>
<li>μοναδικό id (<b>job_id</b>)</li>
<li>δείκτη σε συνάρτηση (<b>start_routine</b>) για τη ρουτίνα εκτέλεσης</li>
<li>πίνακα με τα ορίσματα της ρουτίνας (<b>args</b>)</li>
<li>τιμή επιστροφής της ρουτίνας (<b>return_val</b>)</li>
<li>flag (<b>complete</b>) που υποδηλώνει αν το job ολοκληρώθηκε ή όχι</li>
<li>semaphore (<b>sem_complete</b>) ώστε αν κάποιο νήμα ζητήσει να δει την τιμή επιστροφής του, να είναι εφικτό να μπλοκάρει μέχρι αυτό να ολοκληρωθεί.</li>
</ul>
<p><em>Αναπαράσταση της δομής <a class="el" href="structjob__scheduler.html">job_scheduler</a>:</em> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structjob__scheduler.html">job_scheduler</a> {  </div>
<div class="line">     uint execution_threads;  </div>
<div class="line">     pthread_t *tids;  </div>
<div class="line">     <a class="code" href="structqueue__t.html">Queue</a> waiting_queue;  </div>
<div class="line">     <a class="code" href="structqueue__t.html">Queue</a> running_queue;  </div>
<div class="line">     <span class="keywordtype">bool</span> working;  </div>
<div class="line">     <span class="keywordtype">bool</span> exit;  </div>
<div class="line">     <span class="keywordtype">int</span> ready;</div>
<div class="line">     <span class="comment">/* sync */</span>   </div>
<div class="line">     pthread_cond_t condition_wake_up;  </div>
<div class="line">     pthread_cond_t condition_wake_up_submitter;  </div>
<div class="line">     pthread_mutex_t mutex;  </div>
<div class="line">     pthread_mutex_t mutex_submitter;  </div>
<div class="line">     <a class="code" href="structsemaphore.html">sem_t_</a> *sem_barrier;  </div>
<div class="line">};</div>
<div class="ttc" id="astructjob__scheduler_html"><div class="ttname"><a href="structjob__scheduler.html">job_scheduler</a></div><div class="ttdef"><b>Definition:</b> job_scheduler.c:51</div></div>
<div class="ttc" id="astructqueue__t_html"><div class="ttname"><a href="structqueue__t.html">queue_t</a></div><div class="ttdef"><b>Definition:</b> queue.c:17</div></div>
<div class="ttc" id="astructsemaphore_html"><div class="ttname"><a href="structsemaphore.html">semaphore</a></div><div class="ttdef"><b>Definition:</b> semaphore.c:12</div></div>
</div><!-- fragment --><p> Η δομή του Job Scheduler έχει τα παρακάτω χαρακτηριστικά:</p><ul>
<li>Αριθμός διαθέσιμων νημάτων (<b>execution_threads</b>) για εκτέλεση εργασιών.</li>
<li>Πίνακας με τα αναγνωριστικά των νημάτων (<b>tids</b>) που χρησιμοποιείται για την εύρεσή τους με σκοπό την ένωσή τους με το αρχικό νήμα κάνοντάς κλήση της συνάρτησής <b>pthread_join</b>.</li>
<li>Ουρά αναμονής (<b>waiting_queue</b>) προς εκτέλεση εργασιών.</li>
<li>Ουρά εργασιών που ξεκίνησαν να τρέχουν (<b>running_queue</b>) η οποία χρησιμοποιείται για να τα συλλέξει με τη σωστή σειρά το master thread όταν θα έχουν ολοκληρωθεί όλα.</li>
<li>Flag (<b>working</b>) που χρησιμοποιείται για να υποδηλώσει ένα ενεργό <b>work cycle</b> όταν έχει την τιμή true και <b>barrier ready</b> όταν έχει την τιμή false.</li>
<li>Flag (<b>exit</b>) που υποδηλώνει ότι το master thread αποφάσισε να μη χρησιμοποιήσει άλλο τον scheduler. Αν λάβει την τιμή true, τότε όταν το κάθε νήμα "ξυπνήσει" θα καλέσει την <b>pthread_exit</b>.</li>
<li>Μετρητής έτοιμων νημάτων (<b>ready</b>) που δεν τρέχουν κάποια εργασία αυτή τη στιγμή.</li>
</ul>
<p>Ενώ για τον συγχρονισμό:</p><ul>
<li>Mutex (<b>mutex</b>) που χρησιμοποιείται για τον αμοιβαίο αποκλεισμό των άλλων νημάτων στις περιπτώσεις που χρειάζεται.</li>
<li>Condition variable (<b>condition_wake_up</b>) που χρησιμοποιείται για να μπλοκάρουν τα νήματα που είναι έτοιμα και δεν υπάρχει ακόμα διαθέσιμο job.</li>
<li>Mutex αποστολέα (<b>mutex_submitter</b>) για τον αμοιβαίο αποκλεισμό των υπόλοιπων νημάτων που προσπαθούν εκείνη τη στιγμή ταυτόχρονα να βάλουν μία νέα εργασία στην ουρά.</li>
<li>Condition variable (<b>condition_wake_up_submitter</b>) που χρησιμοποιείται για να μπλοκάρει μέχρι να υπάρξει κάποιο διαθέσιμο νήμα.</li>
<li>Custom semaphore (<b>sem_barrier</b>) που χρησιμοποιείται για να ενημερώσει το master thread που έχει καλέσει τη <b>join_threads</b> ότι όλα τα νήματα είναι έτοιμα.</li>
</ul>
<h4><a class="anchor" id="autotoc_md33"></a>
Αντιγραφή ορισμάτων στην ρουτίνα</h4>
<p>Για την αντιγραφή των ορισμάτων που δίνει ο χρήστης από το master νήμα στη ρουτίνα του αντίστοιχου νήματος μέσω της συνάρτησης <code>submit_job</code> κάνουμε χρήση των <a href="https://en.cppreference.com/w/cpp/language/variadic_arguments">Variadic arguments</a> για να τα παίρνουμε με δυναμικό τρόπο χωρίς να είναι απαραίτητο να δημιουργηθεί από το χρήστη κάποια δομή από ορίσματα. Τέλος, τα αντιγράφουμε σε έναν πίνακα από <code>Argument</code> το μέγεθος του οποίου, αυξάνεται δυναμικά με realloc ανάλογα με τον αριθμό των ορισμάτων που δίνει ο χρήστης.</p>
<p>*Αναπαράσταση της διαδικασίας αντιγραφής των ορισμάτων σε πίνακα (<code>submit_job</code>):* </p><div class="fragment"><div class="line">va_start(vargs, start_routine);  </div>
<div class="line">FOREACH_ARG(arg, vargs) {  </div>
<div class="line">    <span class="keywordtype">size_t</span> type_sz = va_arg(vargs, <span class="keywordtype">size_t</span>);  </div>
<div class="line">  (*job)-&gt;args = realloc((*job)-&gt;args, (i + 1) * <span class="keyword">sizeof</span>(<a class="code" href="structargument.html">Argument</a>));  </div>
<div class="line">  (*job)-&gt;args[i].arg = malloc(type_sz);  </div>
<div class="line">  assert((*job)-&gt;args[i].arg != NULL);  </div>
<div class="line">  memcpy((*job)-&gt;args[i].arg, arg, type_sz);  </div>
<div class="line">  (*job)-&gt;args[i].type_sz = type_sz;  </div>
<div class="line">  (*job)-&gt;args_count++;  </div>
<div class="line">};  </div>
<div class="line">va_end(vargs);</div>
</div><!-- fragment --><p> Για την αντίστροφη διαδικασία, όπου ο χρήστης θέλει να πάρει μέσα από τη ρουτίνα τα ορίσματα που έδωσε στην <code>submit_job</code> το μόνο που έχει να κάνει είναι να καλέσει την <code>js_get_args</code> και να δώσει σε αυτήν το job της ρουτίνας καθώς και τη διεύθυνση από τις μεταβλητές που θέλει να αρχικοποιήσει με τα αντίστοιχα ορίσματα. Τα ορίσματα πρέπει να τα δώσει με την ίδια σειρά που τα έγραψε και στη <code>submit_job</code>.</p>
<p><em>Αναπαράσταση της διαδικασίας αρχικοποίησης μεταβλητών :</em> </p><div class="fragment"><div class="line">js_get_args(<a class="code" href="structjob.html">job</a>, &amp;js, &amp;sum, &amp;computations, &amp;mtx, NULL);</div>
</div><!-- fragment --><p><em>Αναπαράσταση της διαδικασίας αντιγραφής των ορισμάτων από τον πίνακα ορισμάτων στην αντίστοιχη μεταβλητή <code>arg</code> :</em> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> js_get_args(<a class="code" href="structjob.html">Job</a> <a class="code" href="structjob.html">job</a>, ...) {  </div>
<div class="line">    va_list vargs;  </div>
<div class="line">  va_start(vargs, <a class="code" href="structjob.html">job</a>);  </div>
<div class="line">  FOREACH_ARG(arg, vargs) {  </div>
<div class="line">        memcpy(arg, <a class="code" href="structjob.html">job</a>-&gt;args[i].arg, <a class="code" href="structjob.html">job</a>-&gt;args[i].type_sz);  </div>
<div class="line">  };  </div>
<div class="line">  va_end(vargs);  </div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md34"></a>
Δεξαμενή νημάτων</h3>
<p>Ο Job scheduler αναλαμβάνει να τρέξει εργασίες (jobs) σε διαφορετικά νήματα με <b>FIFO</b> (First In First Out) σειρά και αυτό το επιτυγχάνει με μια ουρά αναμονής (waiting_queue).</p>
<h4><a class="anchor" id="autotoc_md35"></a>
Κύκλος εκτέλεσης εργασιών</h4>
<p><em>Αναπαράσταση της συνάρτησης thread:</em> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> *thread(<a class="code" href="structjob__scheduler.html">JobScheduler</a> js) {</div>
<div class="line">    <span class="keywordtype">int</span> jobs_count = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        LOCK_;</div>
<div class="line">        <span class="keywordflow">while</span> ((!js-&gt;working &amp;&amp; !js-&gt;exit) || (!queue_size(js-&gt;waiting_queue) &amp;&amp; !js-&gt;exit)) {</div>
<div class="line">            js-&gt;ready++;</div>
<div class="line">            <span class="keywordflow">if</span> (js-&gt;ready == js-&gt;execution_threads) {</div>
<div class="line">                js-&gt;working = <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">            pthread_cond_signal(&amp;js-&gt;condition_wake_up_submitter);</div>
<div class="line">            NOTIFY_BARRIER_;</div>
<div class="line">            WAIT_;</div>
<div class="line">            js-&gt;ready--;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (js-&gt;exit &amp;&amp; !queue_size(js-&gt;waiting_queue)) {</div>
<div class="line">            UNLOCK_;</div>
<div class="line">            EXIT_;</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="structjob.html">Job</a> <a class="code" href="structjob.html">job</a> = NULL;</div>
<div class="line">        <span class="keywordflow">if</span> (queue_dequeue(js-&gt;waiting_queue, &amp;<a class="code" href="structjob.html">job</a>, <span class="keyword">false</span>)) {</div>
<div class="line">            jobs_count++;</div>
<div class="line">            queue_enqueue(js-&gt;running_queue, &amp;<a class="code" href="structjob.html">job</a>, <span class="keyword">false</span>);</div>
<div class="line">            queue_unblock_enqueue(js-&gt;waiting_queue);</div>
<div class="line">            UNLOCK_;</div>
<div class="line">            RUN_ROUTINE_;</div>
<div class="line">            <a class="code" href="structjob.html">job</a>-&gt;complete = <span class="keyword">true</span>;</div>
<div class="line">            NOTIFY_JOB_COMPLETE_;</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        UNLOCK_;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Όταν ξεκινάει να λειτουργεί ένα νήμα, εισέρχεται σε έναν ατέρμον βρόγχο, κλειδώνει την πρόσβαση από τα υπόλοιπα νήματα με τη χρήση <code>LOCK_</code> (ή αντίστοιχα περιμένει μέχρι η πρόσβαση για αυτό να είναι εφικτή) και κάνει τους παρακάτω ελέγχους ώστε να αποφασίσει αν πρέπει να μπει σε κατάσταση <code>WAIT_</code>:</p><ul>
<li><code>(!js-&gt;working &amp;&amp; !js-&gt;exit)</code> : Αν δεν έχει ενεργοποιηθεί ακόμα το flag <b>working</b> και <b>exit</b> τότε σημαίνει ότι δεν έχει ληφθεί ακόμα κάποιο σήμα εκκίνησης ή τερματισμού.</li>
<li><code>(!queue_size(js-&gt;waiting_queue) &amp;&amp; !js-&gt;exit)</code> : Αν η ουρά δεν έχει jobs και δεν έχει ληφθεί κάποιο σήμα τερματισμού.</li>
</ul>
<p>Όταν "ξυπνήσει" το νήμα λαμβάνοντας κάποιο <code>BROADCAST_WAKEUP_</code> ή <code>SIGNAL_WAKE_UP_</code> signal, θα ελέγξει εκ νέου αν ισχύουν οι δύο παραπάνω συνθήκες ή όχι (<b>busy waiting</b>) και θα πράξει αναλόγως.</p>
<p>Στην περίπτωση που δεν ισχύει το condition στο while: <code>(!js-&gt;working &amp;&amp; !js-&gt;exit) || (!queue_size(js-&gt;waiting_queue) &amp;&amp; !js-&gt;exit)</code> τότε θα ακολουθήσει ο έλεγχος: <code>js-&gt;exit &amp;&amp; !queue_size(js-&gt;waiting_queue)</code> ο οποίος θα ελέγξει αν ο λόγος που έγινε <b>wake up</b> το νήμα είναι για να τερματίσει (ή όχι) κάνοντας <code>UNLOCK_</code> και καλώντας τη <code>pthread_exit</code> (<code>EXIT_</code>).</p>
<p>Στη συνέχεια, αν το νήμα δεν τερματίσει τότε οι λόγοι που "ξύπνησε" (<b>wake up</b>) είναι οι παρακάτω:</p><ul>
<li>έλαβε κάποιο signal <code>BROADCAST_WAKEUP_</code> από τη συνάρτηση <code>js_execute_all_jobs</code> που αναλαμβάνει να ξυπνήσει όλα τα νήματα για να ξεκινήσουν να τρέχουν τα jobs ή</li>
<li>έλαβε κάποιο signal <code>SIGNAL_WAKEUP_</code> από τη συνάρτηση <code>js_submit_job</code></li>
</ul>
<p>Σε επόμενη φάση αν υπάρχουν στην ουρά αναμονής διαθέσιμες προς εκτέλεση εργασίες, εξάγεται από την ουρά η πρώτη διαθέσιμη, ο μετρητής των εργασιών (<code>jobs_count</code>) που έχει αναλάβει το συγκεκριμένο νήμα αυξάνεται κατά ένα και η εργασία εισέρχεται στη running queue, ενώ αμέσως μετά καλείται η <code>queue_unblock_enqueue</code> ώστε να ξεμπλοκάρει η waiting queue και να μπορέσει να χρησιμοποιηθεί από κάποιο άλλο νήμα. Κατόπιν γίνεται <code>UNLOCK_</code>για να μπορέσουν και άλλα νήματα να έχουν πρόσβαση στους κοινόχρηστους πόρους και εκτελείται η ρουτίνα (<code>RUN_ROUTINE_</code>) με όρισμα το ίδιο το job (<code>job-&gt;return_val = (job-&gt;start_routine)(job)</code>).</p>
<p>Όταν επιστρέψει η συνάρτηση της ρουτίνας, αποθηκεύεται η τιμή επιστροφής (<b>return_val</b>) στη δομή του job ώστε να είναι διαθέσιμη στον client κώδικα.</p>
<p>Στη συνέχεια ενημερώνεται το flag <code>job-&gt;complete</code>σε true και καλείται η <code>sem_post(&amp;job-&gt;sem_complete)</code> (<code>NOTIFY_JOB_COMPLETE_</code>) με σκοπό να ενημερωθεί το master νήμα πως το job ολοκληρώθηκε. Ο λόγος που γίνεται αυτό είναι γιατί μπορεί εκείνη τη στιγμή να είχε μπλοκάρει στις συναρτήσεις <code>js_wait_job</code> ή και <code>js_get_return_val</code> αντίστοιχα.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
Χρήση του Job Scheduler</h3>
<p>Στην υλοποίηση μας για τη μηχανική μάθηση, οι συναρτήσεις train και test περιμένουν έναν buffer με όλα τα διανύσματα που θα χρησιμοποιηθούν για αυτές τις διαδικασίες. Το να γεμίσει αυτός ο buffer κάθε φορά που χρειαζόταν, έπαιρνε αρκετό χρόνο, οπότε η πρώτη διαδικασία που παραλληλίσαμε ήταν αυτή. Πιο συγκεκριμένα, κάθε job αναλάμβανε να βάλει ένα διάνυσμα στο σωστό σημείο του buffer. Με αυτό τον τρόπο επιτυγχάνουμε ταυτόχρονο γέμισμα του buffer.</p>
<p>Άλλο ένα σημείο στο οποίο παραλληλοποιήσαμε ήταν ο υπολογισμός των Deltas στη διαδικασία του training. Κάθε job αναλαμβάνει να υπολογίσει από ένα στοιχείο του Deltas array.</p>
<p>Τέλος, παραλληλοποιήσαμε τη διαδικασία του predict, έτσι ώστε κάθε job να αναλαμβάνει να εκτελέσει το prediction ενός ζευγαριού και να το τοποθετεί στο σωστό σημείο του πίνακα με τα συνολικά predictions.</p>
<p>Σκοπεύαμε αν προλαβαίναμε, για να παρατηρήσουμε αν θα υπάρξει διαφορά στο χρόνο εκτέλεσης του προγράμματος, να αλλάζαμε τη διαδικασία της παραλληλοποίησης και να δίναμε στα jobs περισσότερες απο μία επαναλήψεις ώστε να γίνονταν περισσότερες πράξεις σε κάθε job.</p>
<p><a class="anchor" id="unit_tests"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md37"></a>
Unit tests</h2>
<p>Κάθε module (<b>list</b>, <b>hash table</b>, <b>hset</b>, <b><a class="el" href="structjob__scheduler.html">job_scheduler</a></b>, <b>json_parser</b>, <b>ml</b>, <b>logreg</b>, <b>queue</b>, κτλ) έχει αντίστοιχα και τα δικά του unit tests τα οποία βρίσκονται σε διαφορετικά αρχεία το καθένα. Για την υλοποίησή τους, κάνουμε χρήση της βιβλιοθήκης <a href="https://github.com/mity/acutest">Acutest</a>. Όταν επιχειρούμε να κάνουμε complile (make), commit ή push εκτελούνται τα <b>unit tests</b> και αν τερματίσουν επιτυχώς, πραγματοποιείται με επιτυχία η αντίστοιχη διαδικασία.</p>
<p>Επιπλέον, τα test αυτά εκτελούνται remotely μέσω των <b>github actions (CI)</b>.</p>
<p><a class="anchor" id="documentation"></a> <br  />
 </p>
<h2><a class="anchor" id="autotoc_md38"></a>
Documentation</h2>
<p>Στον σύνδεσμο <a href="https://k23a-prj-auth.herokuapp.com">Documentation</a> που βρίσκεται και στην πρώτη σελίδα του report βρίσκεται το <b>documentation</b> (<b>man pages</b>) των βιβλιοθηκών που έχουν υλοποιηθεί. Πρόσβαση επιτρέπεται μόνο στους <b>contributors</b> του project (δηλαδή την ομάδα μας και το βοηθό του τμήματός μας) και πρέπει να γίνει <b>authentication</b> μέσω <b>github</b>, ώστε να μην μπορεί κάποιος άλλος να αποκτήσει πρόσβαση.</p>
<p>Το Documentation υλοποιήθηκε μέσω του <a href="https://www.doxygen.nl/index.html">Doxygen</a>. Τα man pages αυτά ανανεώνονται κάθε φορά που προστίθεται νέο commit στο master. Τα output αρχεία του <b>Doxygen</b> γίνονται push στο branch "**docs**" και από εκεί ενημερώνεται το documentation site μας. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
