<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>K23a Project: Lists</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">K23a Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Lists</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic linked list interface. Consult for functions and types with prefix 'll_'.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacd1e0a778d730e22bcd910d8ff86f336"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#gacd1e0a778d730e22bcd910d8ff86f336">LISTOF</a>(TYPE)</td></tr>
<tr class="memdesc:gacd1e0a778d730e22bcd910d8ff86f336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to easily create list types.  <a href="group__lists.html#gacd1e0a778d730e22bcd910d8ff86f336">More...</a><br /></td></tr>
<tr class="separator:gacd1e0a778d730e22bcd910d8ff86f336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5af49abed9587852c20ae9e254346d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga9e5af49abed9587852c20ae9e254346d">LL_FOREACH</a>(VAR,  LIST)</td></tr>
<tr class="memdesc:ga9e5af49abed9587852c20ae9e254346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements foreach functionality for lists.  <a href="group__lists.html#ga9e5af49abed9587852c20ae9e254346d">More...</a><br /></td></tr>
<tr class="separator:ga9e5af49abed9587852c20ae9e254346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf79ae2fc91143dad81826248d6081eea"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#gaf79ae2fc91143dad81826248d6081eea">mapfunc_t</a>) (void *node, va_list vargs)</td></tr>
<tr class="memdesc:gaf79ae2fc91143dad81826248d6081eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type for ll_map. Should map a list node to a new one.  <a href="group__lists.html#gaf79ae2fc91143dad81826248d6081eea">More...</a><br /></td></tr>
<tr class="separator:gaf79ae2fc91143dad81826248d6081eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb1065a53077defb98cafa7f1518fe1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga3cb1065a53077defb98cafa7f1518fe1">llfree_f</a>) (void *node)</td></tr>
<tr class="memdesc:ga3cb1065a53077defb98cafa7f1518fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free-ing function type for ll_free.  <a href="group__lists.html#ga3cb1065a53077defb98cafa7f1518fe1">More...</a><br /></td></tr>
<tr class="separator:ga3cb1065a53077defb98cafa7f1518fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1082c7d8d35a4c931c6dbebbcc24ba8"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#gab1082c7d8d35a4c931c6dbebbcc24ba8">llpred</a>) (void *nodeptr, va_list vargs)</td></tr>
<tr class="memdesc:gab1082c7d8d35a4c931c6dbebbcc24ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate function type for llmap.  <a href="group__lists.html#gab1082c7d8d35a4c931c6dbebbcc24ba8">More...</a><br /></td></tr>
<tr class="separator:gab1082c7d8d35a4c931c6dbebbcc24ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e15cf570d245863260decbd829aeb55"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a>) (void *node_a, void *node_b)</td></tr>
<tr class="memdesc:ga0e15cf570d245863260decbd829aeb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator function type for ll_sort.  <a href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">More...</a><br /></td></tr>
<tr class="separator:ga0e15cf570d245863260decbd829aeb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8ae105b28e0b40591482f6ae62140d93"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a> (void *l, int n)</td></tr>
<tr class="memdesc:ga8ae105b28e0b40591482f6ae62140d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nth element of a list.  <a href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">More...</a><br /></td></tr>
<tr class="separator:ga8ae105b28e0b40591482f6ae62140d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ef7ff272bf4f813b99023a53a3499f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga74ef7ff272bf4f813b99023a53a3499f">ll_tail</a> (void *l)</td></tr>
<tr class="memdesc:ga74ef7ff272bf4f813b99023a53a3499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last element of a list.  <a href="group__lists.html#ga74ef7ff272bf4f813b99023a53a3499f">More...</a><br /></td></tr>
<tr class="separator:ga74ef7ff272bf4f813b99023a53a3499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f9748867a0a32abf9eefcf330247ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga33f9748867a0a32abf9eefcf330247ee">ll_push</a> (void *lp, void *node)</td></tr>
<tr class="memdesc:ga33f9748867a0a32abf9eefcf330247ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes node the new head of the list pointed to by lp.  <a href="group__lists.html#ga33f9748867a0a32abf9eefcf330247ee">More...</a><br /></td></tr>
<tr class="separator:ga33f9748867a0a32abf9eefcf330247ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb5f648214a7d0905addd57ce26e95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga2fb5f648214a7d0905addd57ce26e95a">ll_pushlist</a> (void *lp, void *node)</td></tr>
<tr class="memdesc:ga2fb5f648214a7d0905addd57ce26e95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like ll_push but if NEXT(node) is a list, the whole list is pushed to lp.  <a href="group__lists.html#ga2fb5f648214a7d0905addd57ce26e95a">More...</a><br /></td></tr>
<tr class="separator:ga2fb5f648214a7d0905addd57ce26e95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga544fc4433b544bb770b14b88abcd7620"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga544fc4433b544bb770b14b88abcd7620">ll_pop</a> (void *lp)</td></tr>
<tr class="memdesc:ga544fc4433b544bb770b14b88abcd7620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and returns the first node of the list pointed to by lp.  <a href="group__lists.html#ga544fc4433b544bb770b14b88abcd7620">More...</a><br /></td></tr>
<tr class="separator:ga544fc4433b544bb770b14b88abcd7620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b45d675ec260537e74c82982462a28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#gab7b45d675ec260537e74c82982462a28">ll_len</a> (void *l)</td></tr>
<tr class="memdesc:gab7b45d675ec260537e74c82982462a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the nodes of a list.  <a href="group__lists.html#gab7b45d675ec260537e74c82982462a28">More...</a><br /></td></tr>
<tr class="separator:gab7b45d675ec260537e74c82982462a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a71596ed4594b91673f86c9649487c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#gac1a71596ed4594b91673f86c9649487c">ll_reverse</a> (void *lp)</td></tr>
<tr class="memdesc:gac1a71596ed4594b91673f86c9649487c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the list pointed to by lp in place.  <a href="group__lists.html#gac1a71596ed4594b91673f86c9649487c">More...</a><br /></td></tr>
<tr class="separator:gac1a71596ed4594b91673f86c9649487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d6cd7af6cbbeeb85023bc163189cc8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga17d6cd7af6cbbeeb85023bc163189cc8">ll_map</a> (void *INs, <a class="el" href="group__lists.html#gaf79ae2fc91143dad81826248d6081eea">mapfunc_t</a> map_func,...)</td></tr>
<tr class="memdesc:ga17d6cd7af6cbbeeb85023bc163189cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list to a new one according to mapping function.  <a href="group__lists.html#ga17d6cd7af6cbbeeb85023bc163189cc8">More...</a><br /></td></tr>
<tr class="separator:ga17d6cd7af6cbbeeb85023bc163189cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0266116f1e3e18777a3b0ec10d465d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga0266116f1e3e18777a3b0ec10d465d1c">ll_free</a> (void *l, <a class="el" href="group__lists.html#ga3cb1065a53077defb98cafa7f1518fe1">llfree_f</a> free_data)</td></tr>
<tr class="memdesc:ga0266116f1e3e18777a3b0ec10d465d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the input list, freeing all the nodes with free_node.  <a href="group__lists.html#ga0266116f1e3e18777a3b0ec10d465d1c">More...</a><br /></td></tr>
<tr class="separator:ga0266116f1e3e18777a3b0ec10d465d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14bf899408a8fad50586178930c5b5ba"><td class="memItemLeft" align="right" valign="top"><a id="ga14bf899408a8fad50586178930c5b5ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ll_iterate</b> (void *l, void(*callback)(void *))</td></tr>
<tr class="separator:ga14bf899408a8fad50586178930c5b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a28e56b2ed7e7fdf84bf23936891db8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga9a28e56b2ed7e7fdf84bf23936891db8">ll_search</a> (void *l, <a class="el" href="group__lists.html#gab1082c7d8d35a4c931c6dbebbcc24ba8">llpred</a> p,...)</td></tr>
<tr class="memdesc:ga9a28e56b2ed7e7fdf84bf23936891db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a list.  <a href="group__lists.html#ga9a28e56b2ed7e7fdf84bf23936891db8">More...</a><br /></td></tr>
<tr class="separator:ga9a28e56b2ed7e7fdf84bf23936891db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a270a122b4a43205604ddefc779c8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga7a270a122b4a43205604ddefc779c8a5">ll_split</a> (void *in, void *out_a, void *out_b, int n)</td></tr>
<tr class="memdesc:ga7a270a122b4a43205604ddefc779c8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits in to out_a and out_b, giving the first n nodes to out_a and the rest to b.  <a href="group__lists.html#ga7a270a122b4a43205604ddefc779c8a5">More...</a><br /></td></tr>
<tr class="separator:ga7a270a122b4a43205604ddefc779c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46adee4a5d5d6936ce64f9811fb8b751"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga46adee4a5d5d6936ce64f9811fb8b751">ll_sort_merge</a> (void *list_a, void *list_b, <a class="el" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a> c)</td></tr>
<tr class="memdesc:ga46adee4a5d5d6936ce64f9811fb8b751"><td class="mdescLeft">&#160;</td><td class="mdescRight">The merging part of the merge sort algorithm.  <a href="group__lists.html#ga46adee4a5d5d6936ce64f9811fb8b751">More...</a><br /></td></tr>
<tr class="separator:ga46adee4a5d5d6936ce64f9811fb8b751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a056fa2b33c6de039fd57c984343ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">ll_sort</a> (void *l, <a class="el" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a> c)</td></tr>
<tr class="memdesc:ga54a056fa2b33c6de039fd57c984343ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the input list in place using merge sort.  <a href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">More...</a><br /></td></tr>
<tr class="separator:ga54a056fa2b33c6de039fd57c984343ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Generic linked list interface. Consult for functions and types with prefix 'll_'. </p>
<p>A generic linked list interface. Can be applied to any linked list structure as long as the pointer to the next element is the first field of the struct. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacd1e0a778d730e22bcd910d8ff86f336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd1e0a778d730e22bcd910d8ff86f336">&#9670;&nbsp;</a></span>LISTOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LISTOF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to easily create list types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TYPE</td><td>the type of data stored in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e5af49abed9587852c20ae9e254346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e5af49abed9587852c20ae9e254346d">&#9670;&nbsp;</a></span>LL_FOREACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LL_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">VAR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LIST&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements foreach functionality for lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">VAR</td><td>an identifier that references the current node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LIST</td><td>the list</td></tr>
  </table>
  </dd>
</dl>
<p>read as "for each VAR in LIST"</p>
<h3><a class="anchor" id="autotoc_md1"></a>
example:</h3>
<div class="fragment"><div class="line">list *Ls = function_that_produces_list(...);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__lists.html#ga9e5af49abed9587852c20ae9e254346d">LL_FOREACH</a>(L, Ls){</div>
<div class="line">    action(L);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_ga9e5af49abed9587852c20ae9e254346d"><div class="ttname"><a href="group__lists.html#ga9e5af49abed9587852c20ae9e254346d">LL_FOREACH</a></div><div class="ttdeci">#define LL_FOREACH(VAR, LIST)</div><div class="ttdoc">Implements foreach functionality for lists.</div><div class="ttdef"><b>Definition:</b> lists.h:53</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0e15cf570d245863260decbd829aeb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e15cf570d245863260decbd829aeb55">&#9670;&nbsp;</a></span>llcmpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* llcmpr) (void *node_a, void *node_b)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparator function type for ll_sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_a</td><td>: a list node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_b</td><td>: a list node </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">c</td><td>where<br  />
c &gt; 0 iff. node_a &gt; node_b,<br  />
c &lt; 0 iff. node_a &lt; node_b and<br  />
c = 0 iff. node_a = node_b. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cb1065a53077defb98cafa7f1518fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb1065a53077defb98cafa7f1518fe1">&#9670;&nbsp;</a></span>llfree_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* llfree_f) (void *node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free-ing function type for ll_free. </p>
<p>The logical equivalent of calling free(node) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>a list node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1082c7d8d35a4c931c6dbebbcc24ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1082c7d8d35a4c931c6dbebbcc24ba8">&#9670;&nbsp;</a></span>llpred</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* llpred) (void *nodeptr, va_list vargs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate function type for llmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeptr</td><td>: a list node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vargs</td><td>: va_list passed to the predicate by ll_search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false, depending on whether the node is a match for the predicate according to <code>vargs</code> </dd></dl>

</div>
</div>
<a id="gaf79ae2fc91143dad81826248d6081eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf79ae2fc91143dad81826248d6081eea">&#9670;&nbsp;</a></span>mapfunc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* mapfunc_t) (void *node, va_list vargs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type for ll_map. Should map a list node to a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>a list node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vargs</td><td>a va_list with the extra arguments passed to ll_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">out</td><td>a new list node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0266116f1e3e18777a3b0ec10d465d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0266116f1e3e18777a3b0ec10d465d1c">&#9670;&nbsp;</a></span>ll_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ll_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lists.html#ga3cb1065a53077defb98cafa7f1518fe1">llfree_f</a>&#160;</td>
          <td class="paramname"><em>free_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the input list, freeing all the nodes with free_node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>: a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_node</td><td>: a function that frees a single node from <code>l</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7b45d675ec260537e74c82982462a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7b45d675ec260537e74c82982462a28">&#9670;&nbsp;</a></span>ll_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ll_len </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the nodes of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>: a list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of l </dd></dl>

</div>
</div>
<a id="ga17d6cd7af6cbbeeb85023bc163189cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17d6cd7af6cbbeeb85023bc163189cc8">&#9670;&nbsp;</a></span>ll_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ll_map </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>INs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lists.html#gaf79ae2fc91143dad81826248d6081eea">mapfunc_t</a>&#160;</td>
          <td class="paramname"><em>map_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a list to a new one according to mapping function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">INs</td><td>: an input list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_func</td><td>: function used to produce the output list </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OUTs</td><td>a list where the nth node is the output of mapfunc(nth node of INs) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ae105b28e0b40591482f6ae62140d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae105b28e0b40591482f6ae62140d93">&#9670;&nbsp;</a></span>ll_nth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ll_nth </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nth element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>: a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth element of l </dd></dl>

</div>
</div>
<a id="ga544fc4433b544bb770b14b88abcd7620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga544fc4433b544bb770b14b88abcd7620">&#9670;&nbsp;</a></span>ll_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ll_pop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts and returns the first node of the list pointed to by lp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lp</td><td>: a pointer to a list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node pointed to by <code>lp</code></dd></dl>
<h3><a class="anchor" id="autotoc_md4"></a>
example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> pop_test(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordtype">int</span> N = 5;</div>
<div class="line">    list *Is = make_list(N);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (Is) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; <a class="code" href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a>(Is, i); i++) {</div>
<div class="line">            list *temp = <a class="code" href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a>(Is, i);</div>
<div class="line">            assert(temp-&gt;data == i + counter);</div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="group__lists.html#ga544fc4433b544bb770b14b88abcd7620">ll_pop</a>(&amp;Is);</div>
<div class="line">        counter++;</div>
<div class="line">    }</div>
<div class="line">    assert(counter == N);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_ga544fc4433b544bb770b14b88abcd7620"><div class="ttname"><a href="group__lists.html#ga544fc4433b544bb770b14b88abcd7620">ll_pop</a></div><div class="ttdeci">void * ll_pop(void *lp)</div><div class="ttdoc">Extracts and returns the first node of the list pointed to by lp.</div><div class="ttdef"><b>Definition:</b> lists.c:81</div></div>
<div class="ttc" id="agroup__lists_html_ga8ae105b28e0b40591482f6ae62140d93"><div class="ttname"><a href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a></div><div class="ttdeci">void * ll_nth(void *l, int n)</div><div class="ttdoc">Finds the nth element of a list.</div><div class="ttdef"><b>Definition:</b> lists.c:18</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga33f9748867a0a32abf9eefcf330247ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f9748867a0a32abf9eefcf330247ee">&#9670;&nbsp;</a></span>ll_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ll_push </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes node the new head of the list pointed to by lp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lp</td><td>: a pointer to a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>: a node where NEXT(<code>node</code>) is a list </td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md2"></a>
example:</h3>
<div class="fragment"><div class="line">list *make_list(<span class="keywordtype">int</span> N) {</div>
<div class="line">    <span class="keyword">static</span> list some_nodes[100];</div>
<div class="line">    list *out = NULL;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = N - 1; i &gt;= 0; i--) {</div>
<div class="line">    <span class="comment">// inserting at the start of the list should reverse the elements</span></div>
<div class="line">    <span class="comment">// we expect the list to be (0, 1, 2, 3, .. N)</span></div>
<div class="line">        some_nodes[i].data = i;</div>
<div class="line">        <a class="code" href="group__lists.html#ga33f9748867a0a32abf9eefcf330247ee">ll_push</a>(&amp;out, &amp;some_nodes[i]);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_ga33f9748867a0a32abf9eefcf330247ee"><div class="ttname"><a href="group__lists.html#ga33f9748867a0a32abf9eefcf330247ee">ll_push</a></div><div class="ttdeci">void ll_push(void *lp, void *node)</div><div class="ttdoc">Makes node the new head of the list pointed to by lp.</div><div class="ttdef"><b>Definition:</b> lists.c:47</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2fb5f648214a7d0905addd57ce26e95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb5f648214a7d0905addd57ce26e95a">&#9670;&nbsp;</a></span>ll_pushlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ll_pushlist </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like ll_push but if NEXT(node) is a list, the whole list is pushed to lp. </p>
<p>Connects ll_tail(node) to *lp and sets *lp to node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lp</td><td>: a pointer to a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>: a node where NEXT(<code>node</code>) is a list</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md3"></a>
example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> pushlist_test(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordtype">int</span> N = 5, M = 5;</div>
<div class="line">    list *As, *Bs;</div>
<div class="line">    list Anodes[N];</div>
<div class="line">    list Bnodes[M];</div>
<div class="line">    As = make_list_r(N, Anodes);</div>
<div class="line">    Bs = make_list_r(M, Bnodes);</div>
<div class="line"> </div>
<div class="line">    llpushlist(&amp;As, Bs);</div>
<div class="line"> </div>
<div class="line">    assert(<a class="code" href="group__lists.html#gab7b45d675ec260537e74c82982462a28">ll_len</a>(As) == N + M);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N + M; i++) {</div>
<div class="line">        list *temp = <a class="code" href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a>(As, i);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (temp)</div>
<div class="line">            assert(temp-&gt;data == i - (i &gt;= M ? M : 0));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_gab7b45d675ec260537e74c82982462a28"><div class="ttname"><a href="group__lists.html#gab7b45d675ec260537e74c82982462a28">ll_len</a></div><div class="ttdeci">int ll_len(void *l)</div><div class="ttdoc">Counts the nodes of a list.</div><div class="ttdef"><b>Definition:</b> lists.c:95</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac1a71596ed4594b91673f86c9649487c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a71596ed4594b91673f86c9649487c">&#9670;&nbsp;</a></span>ll_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ll_reverse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the list pointed to by lp in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lp</td><td>: input list pointer</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md5"></a>
example</h3>
<div class="fragment"><div class="line"><span class="comment">// L = (1, 2, 3)</span></div>
<div class="line"><a class="code" href="group__lists.html#gac1a71596ed4594b91673f86c9649487c">ll_reverse</a>(&amp;L);</div>
<div class="line"><span class="comment">// L = (3, 2, 1)</span></div>
<div class="ttc" id="agroup__lists_html_gac1a71596ed4594b91673f86c9649487c"><div class="ttname"><a href="group__lists.html#gac1a71596ed4594b91673f86c9649487c">ll_reverse</a></div><div class="ttdeci">void ll_reverse(void *lp)</div><div class="ttdoc">Reverses the list pointed to by lp in place.</div><div class="ttdef"><b>Definition:</b> lists.c:110</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga9a28e56b2ed7e7fdf84bf23936891db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a28e56b2ed7e7fdf84bf23936891db8">&#9670;&nbsp;</a></span>ll_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ll_search </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lists.html#gab1082c7d8d35a4c931c6dbebbcc24ba8">llpred</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>: a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>: a predicate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>: arguments passed to p </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first node of l for which p(l, ...) returns true </dd></dl>

</div>
</div>
<a id="ga54a056fa2b33c6de039fd57c984343ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54a056fa2b33c6de039fd57c984343ad">&#9670;&nbsp;</a></span>ll_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ll_sort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the input list in place using merge sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lp</td><td>: a pointer to a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: a comparison function</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> sort_test(<span class="keywordtype">void</span>) {</div>
<div class="line">    list *As = make_list2((<span class="keywordtype">int</span>[]){1, 9, 2, 4, 3, 7, 6, 5, 8, 0}, 10);</div>
<div class="line">    <span class="comment">// As = (1, 9, 2, 4, 3, 7, 6, 5, 8, 0)</span></div>
<div class="line">    <a class="code" href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">ll_sort</a>(&amp;As, (<a class="code" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a>)&amp;int_sort);</div>
<div class="line">    <span class="keywordflow">for</span> (list *A = As; A; A = <a class="code" href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a>(A, 1)) {</div>
<div class="line">        list *nextA = <a class="code" href="group__lists.html#ga8ae105b28e0b40591482f6ae62140d93">ll_nth</a>(A, 1);</div>
<div class="line">        <span class="keywordflow">if</span> (nextA) {</div>
<div class="line">            assert(A-&gt;data &lt;= nextA-&gt;data);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_ga0e15cf570d245863260decbd829aeb55"><div class="ttname"><a href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a></div><div class="ttdeci">int(* llcmpr)(void *node_a, void *node_b)</div><div class="ttdoc">Comparator function type for ll_sort.</div><div class="ttdef"><b>Definition:</b> lists.h:98</div></div>
<div class="ttc" id="agroup__lists_html_ga54a056fa2b33c6de039fd57c984343ad"><div class="ttname"><a href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">ll_sort</a></div><div class="ttdeci">void ll_sort(void *l, llcmpr c)</div><div class="ttdoc">Sorts the input list in place using merge sort.</div><div class="ttdef"><b>Definition:</b> lists.c:167</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga46adee4a5d5d6936ce64f9811fb8b751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46adee4a5d5d6936ce64f9811fb8b751">&#9670;&nbsp;</a></span>ll_sort_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ll_sort_merge </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>list_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>list_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The merging part of the merge sort algorithm. </p>
<p>This function is exposed to the interface for adding nodes to an already sorted list and maintaining sortedness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list_a</td><td>: a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list_b</td><td>: a list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: a comparison function</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md7"></a>
example</h3>
<div class="fragment"><div class="line"><span class="comment">// file: lists.c</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">ll_sort</a>(<span class="keywordtype">void</span> *lp, <a class="code" href="group__lists.html#ga0e15cf570d245863260decbd829aeb55">llcmpr</a> c) {</div>
<div class="line">    <span class="keywordtype">void</span> *a, *b;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = <a class="code" href="group__lists.html#gab7b45d675ec260537e74c82982462a28">ll_len</a>(NEXT(l));</div>
<div class="line">    <span class="keywordflow">if</span> (len &lt;= 1)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    <a class="code" href="group__lists.html#ga7a270a122b4a43205604ddefc779c8a5">ll_split</a>(lp, &amp;a, &amp;b, len / 2);</div>
<div class="line">    <a class="code" href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">ll_sort</a>(&amp;a, c);</div>
<div class="line">    <a class="code" href="group__lists.html#ga54a056fa2b33c6de039fd57c984343ad">ll_sort</a>(&amp;b, c);</div>
<div class="line">    NEXT(lp) = <a class="code" href="group__lists.html#ga46adee4a5d5d6936ce64f9811fb8b751">ll_sort_merge</a>(&amp;a, &amp;b, c);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_ga46adee4a5d5d6936ce64f9811fb8b751"><div class="ttname"><a href="group__lists.html#ga46adee4a5d5d6936ce64f9811fb8b751">ll_sort_merge</a></div><div class="ttdeci">void * ll_sort_merge(void *list_a, void *list_b, llcmpr c)</div><div class="ttdoc">The merging part of the merge sort algorithm.</div><div class="ttdef"><b>Definition:</b> lists.c:148</div></div>
<div class="ttc" id="agroup__lists_html_ga7a270a122b4a43205604ddefc779c8a5"><div class="ttname"><a href="group__lists.html#ga7a270a122b4a43205604ddefc779c8a5">ll_split</a></div><div class="ttdeci">void ll_split(void *in, void *out_a, void *out_b, int n)</div><div class="ttdoc">Splits in to out_a and out_b, giving the first n nodes to out_a and the rest to b.</div><div class="ttdef"><b>Definition:</b> lists.c:127</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga7a270a122b4a43205604ddefc779c8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a270a122b4a43205604ddefc779c8a5">&#9670;&nbsp;</a></span>ll_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ll_split </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits in to out_a and out_b, giving the first n nodes to out_a and the rest to b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: input list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_a</td><td>: first output list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_b</td><td>: second output list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the length of the first output list</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md6"></a>
example</h3>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="group__lists.html#gacd1e0a778d730e22bcd910d8ff86f336">LISTOF</a>(<span class="keywordtype">int</span>) intList;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){</div>
<div class="line">  intList *Is = NULL;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 10; i &gt; 0; i--){</div>
<div class="line">    intList *<span class="keyword">new</span> = newNode(i); <span class="comment">// creates a node containing i</span></div>
<div class="line">    <a class="code" href="group__lists.html#ga33f9748867a0a32abf9eefcf330247ee">ll_push</a>(&amp;Is, <span class="keyword">new</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Is = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></div>
<div class="line">  intList *oneToFive, *sixToTen;</div>
<div class="line">  <a class="code" href="group__lists.html#ga7a270a122b4a43205604ddefc779c8a5">ll_split</a>(&amp;Is, &amp;oneToFive, &amp;sixToTen, 5);</div>
<div class="line">  printf(<span class="stringliteral">&quot;oneToFive = &quot;</span>);</div>
<div class="line">  printIntList(oneToFive);</div>
<div class="line">  <span class="comment">// oneToFive = (1, 2, 3, 4, 5)</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;sixToTen = &quot;</span>);</div>
<div class="line">  printIntList(sixToTen);</div>
<div class="line">  <span class="comment">// sixToTen = (6, 7, 8, 9, 10)</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lists_html_gacd1e0a778d730e22bcd910d8ff86f336"><div class="ttname"><a href="group__lists.html#gacd1e0a778d730e22bcd910d8ff86f336">LISTOF</a></div><div class="ttdeci">#define LISTOF(TYPE)</div><div class="ttdoc">Macro to easily create list types.</div><div class="ttdef"><b>Definition:</b> lists.h:30</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga74ef7ff272bf4f813b99023a53a3499f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ef7ff272bf4f813b99023a53a3499f">&#9670;&nbsp;</a></span>ll_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ll_tail </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the last element of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>: a list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last node of l </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
